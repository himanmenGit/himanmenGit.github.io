---
layout: post
title: "3.노드기능"
categories:
  - Node
tags:
  - Node
---


## 3.1 REPL 사용하기
- REPL 콘솔 제공
- R(Read), E(Evaluate), P(Print, L(Loop)
- 터미널에 node 입력
- `node helloworld.js`

## 3.2 모듈 만들기
- 노드는 자바스크립트 코드를 모듈로 만들 수 있음.
- 파일 끝에 `module.exports`로 객체를 넘겨 모듈로 만들 값을 지정
- 다른파일에서 require(파일경로)로 가져 올 수 있음
- 중복을 제거 하기 위함
- 자바스크립트와 Node의 모듈로드 방식이 다르다.
  - 동작은 살짝 다르지만 사용은 가능하다.
  - module.exports -> export default
  - require -> import {} from ''

## 3.4 노드 내장 객체 알아보기
- module.export, require 등 Node에 내장되어 있는 객체
- global
  - 브라우저의 window같은 역할, globalThis로 통합
  - 모든 파일에서 접근 가능
  - window처럼 생략도 가능 (console.require도 global 속성)
  - global 속성에 값을 대입하면 다른 파일에서도 사용 가능 (좋은건 아님) 
- console
  - 브라우저의 console객체와 매우 유사
  - console.time, console.timeEnd: 시간 로깅
  - console.error, log, trace: 각 로깅
  - console.dir: 객체 로깅
  - console.table: 테이블로 보여줌
- 타이머
  - set 메서드에 clear 메서드가 대응됨
  - setTimeout(콜백함수, 밀리초) : 주어진 시간 이후에 함수 실행, 비동기 코드
  - setInterval(클백함수, 밀리초): 2초마다 콜백 함수 실행, 비동기 코드
  - setImmediate(콜백함수): 바로 실행되는 콜백 함수, 비동기 코드
    - setTimeout(func, 0)보다 이것을 사용하는게 좋다.
    - 함수를 백그라운드에 넘겨서 특정 코드들을 동시에 실행 하게 하기 위함 
  - clearTimeout(setTimeout 변수) : setTimeout을 없앨 수 있다.
  - clearInterval(setInterval 변수) : setInterval을 없앨 수 있다.
  - clearImmediate(setImmediate 변수): setImmeidate를 취소 할 수 있다.
- __filename, __dirname
  - REPL에서는 안된다.
  - __filename: 현재 파일 경로
  - __dirname: 현재 폴더 경로
- module, exports
  - module.exports === exports === {}
  - module.exports를 사용했으면 module.exports만 사용해야 한다.
  - module.exports는 1가지를 return 할 때 쓰고
  - 2가지 이상을 return 할때는 exprot.obj를 쓴다
  - module.exports와 exports를 동시에 사용할 수 없다.
- this
  - 노드에서 this사용시 주의점
    - 전역this는 module.exports와 동일한 빈 객체
    - 지역this(function 내부)는 global객체
- require
  - require가 제일 위에 올 필요 없음
    - import .. from 은 제일 위에 있어야 한다.
  - 변수를 가져오고 싶은게 아니라 실행만 하고 싶은 경우 require를 변수에 대입하지 않으면 된다
  - require.main으로 어떤 파일을 실행했는지 알 수 있다.
  - 한번 require했던것은 캐싱을 한다.
- 순환참조
  - 두개의 모듈이 서로를 require하는 상황을 조심
  - Dep1이 Dep2를 require하고 Dep2가 Dep1을 require함
  - 순환참조를 방지 하기 위하여 module.exports를 빈 객체로 만들어 버린다.
- process
  - 현재 실행중인 노드 프로세스에 대한 정보를 담고 있음
  - process.env
    - 시스템 환경 변수
    - 비밀키(데이터베이스 비밀번호 등)을 보관하는 용도로 쓰임
    - 일부 환경변수는 노드 실행 시 영향을 미침
      - UV_THREADPOOL_SIZE(스레드풀 개수)
      - NODE_OPTIONS(노드 실행 옵션)
        - max-old-space-size는 노드가 사용할 수 있는 메모리를 지정
  - process.nextTick
    - 많이 사용하면 다른 콜백이 늦어짐
    - 비슷한 경우로 promise
    - setImeediate, setTImeout보다 promise와 nextTick이 먼저 실행 됨
  - process.exit
    - 프로세스를 종료 할 때 사용
    - 0이면 에러 없어 1이면 에러로 꺼진다는걸 나타냄

## 3.5 노드 내장 모듈
- os 모듈 메서드
  - `const os = require('os')`
  - `os.cpus().length`, `os.type()`, etc..
- path
  - 폴더와 파일의 경로를 처리하기 위함
  - 윈도우와 Linux/mac의 경로가 다르기 떄문에 path를 사용하여 경로를 처리 해야 한다.
    - 운영체제별로 경로 구분자가 다름. (window: \, POSIX:/)
  - mac+linux = POSIX
  - path.join은 절대경로를 무시하고 path.resolve는 절대경로로만 처리한다.
- url
  - 인터넷 주소를 쉽게 조작하도록 도와주는 모듈
  - url 처리에는 크게 두가지 방식 (공식 홈 확인)
    - 기존 노드 방식
    - WHATWG 방식
- searchParams
  - WHATWG 방식에서 쿼리스트링 부분 처리를 도와 주는 객체
- querystring
  - 기조 노드 방식에서 쿼리스트링 부분 처리를 도와주는 모듈
  - `require('querysting')`
- 단방향암호화 (crypto)
  - 암호화는 가능하지만 복호화는 불가능
  - 멀티스레드로 돌아감
  - 단방향 암호화의 대표는 해시 기법
    - 문자열을 고정된 길이의 다른 문자열로 바꾸는 방식
    - 대표적인 단방향 암호화는 비밀번호
- Hash 사용하기(sha512)
  - createHash(알고리즘): 사용할 알고리즘을 넣음
    - md5, sha1, sha256, sha512등 사용가능하지만 md5 와 sha1은 취약점떄문에 쓰지 않는게 좋다
  - update(문자열): 암호화알 문자열을 넣음
  - digest(인코딩): 인코딩할 알고리즘을 넣음
    - base64, hex, latin1이 주로 사용
- pbkdf2
  - 컴퓨터의 발달로 기좀 암호 알고리즘이 취약해지고 있음
  - Node는 pbkdf2와 scrypt지원
  - crypto.randomBytes로 64바이트 문자열 생성 -> salt
  - `pbkdf2(비밀번호, salt, repeat,64, 'sha512')`
  - 반복횟수를 조정하여 암호화시 1초 정도 걸리도록 권장
  - salt는 해독하기 어렵도록 하는 추가 문자열
- 양방향 암호화
  - 대칭형 암호화 (암호문 복호화 가능)
  - 암호화 할 때 복호화와 같은 Key가 사용됨
  - 암호화 -> `createCipheriv` 사용
  - 복호화 -> `createDcipheriv` 사용
  - 생각보다 취약함, Key가 탈취 당할 수 있음
  - 초기화 벡터 공격으로 인한 `iv`를 추가 하여 취약점을 보완함
  - iv의 제약이 많음 Key는 32byte, iv는 16byte등이 필요
  - `crypto-js`등을 사용하여 쉽게 사용 할 수 있다.
  - 단방향 암호화 : SHA512 추천
  - 비대칭 암호화 : RSA 추천
  - 대칭형 암호화 : AES 추천
- util
  - 각종 편의 기능들을 모아 둔 모듈
  - deprecated, promisify 등이 자주 쓰임
  - deprecated로 함수를 감싸면 함수를 쓸 떄마다 경고가 뜬다
  - promisify는 콜백기반으로 작성된 함수를 Promise기반으로 변경 시켜 준다.
    - 콜백이(error, data) => {} 형식이어야 한다
- worker_threads
  - 노드에서 멀티 스레드 방식으로 작업 할 수 있다.
  - isMainThread: 현재 코드가 메인 스레드에서 실행되는지 구분
  - 메인 스레드에서 new Worker를 통해 현재 파일을 워커 스레드에서 실행 시킴
  - worker.postMeassage로 부모에서 워커로 데어틀 보냄
  - parentPort.on('message')로 부모로 부터 데이터를 받음
- child_process
  - 다른언어나 프로세스를 호출 함
  - 실행을 직접하는게 아니라 실행을 요청 하는 것

## 3.6 파일 시스템 접근하기

- fs
  - 파일 시스템에 접근하는 모듈
  - 파일/폴더 생성, 삭제, 읽기, 쓰기 가능
  - 웹 브라우저는 제한적이나 노드는 권한이 있음
- 동기 메서드와 비동기 메서드
  - 매 번 순서가 다르게 실햄됨
  - 순서에 맞게 실행하려면?
    - 함수를 동기식으로 하던가
    - 비동기식으로 유지 하던가 (추천, but 콜백지옥)
      - 동기식이랑 비슷하게 보이나 같은 파일을 여러번 실행하게 될 경우는 파일실행 자체가 백그라운드로 가서 각 파일이 비동기 처리된다.
  - 블로킹과 논 블로킹: 함수가 바로 return 되는지 여부
  - 노드에서는 대부분 동기-블로킹 방식과 비동기-논 블로킹 방식
- 버퍼와 스트림 이해하기
  - 버퍼는 일정한 크기로 모아두는 데이터
    - 일정한 크기가되면 한번에 처리
    - 버퍼링: 버퍼에 데이터가 찰 떄까지 모으는 작업
  - 스트림은 데이터의 흐름
    - 일정한 크기로 나눠서 여러번에 걸쳐서 처리
    - 버퍼의 크기를 작게 만들어 주기적으로 데이터 전달
    - 스트리밍: 일정한 크기의 데이터를 지속적으로 전달하는 작업
- 버퍼 사용 방법
  - `const buffer = Buffer.from('버퍼')`
  - 여러 버퍼 사용
    - `buffer.conact(buffer list)`
  - 빈 버퍼
    - `buffer.alloc(5)`
  - reafFile은 버퍼가 파일사이즈가 동일하다
- 스트림 사용 방법
  - chunk로 조각 낸다
  - `fs.createReadStream('파일')`
  - `fs.createWriteStream('파일')`
- 파이프 (Pipe)
  - `readStream.pipe(writeStream)`
  - 파이프 끼리의 연결로 압축 (파이핑)
    - `pipe(zlibstream).pipe(writeStream)`
- 파일 및 폴더 생성
  - `fs.access`로 폴더 확인 후 `fs.mkdir`로 폴더 생성
  - `fs.open`으로 파일 만들기 
  - `fs.rename`으로 파일명 변경
- 폴더 내용 확인 및 삭제
  - `fs.readdir` 폴더 내용물 확인
  - `fs.unlink` 파일 삭제 (파일 존재 체크 필수)
  - `fs.rmdir` 폴더 삭제 (내부 파일 삭제 후 호출)
  - `fs.existsSync` 파일이 있는지 확인
  - `fs.stat` 파일이 폴더 인지 파일인지 확인 바로가기 등인지 확인
- 파일 복사
  - `fs.copyFile`
- 파일 감시
  - `fs.watch`
- 스레드 풀 알아보기
  - fs, crypto, zlib 모듈은 메서드를 실행할 때 백그라운드에서 동시에 실행
    - 스레드 풀이 동시에 처리 해줌 (기본 4개)
  - UV_THREADPOOL_SIZE=8 (터미널, 파워쉘 안먹힘..)
- 커스텀 이벤트
  - 이벤트 패턴으로 여러 파일간의 동작을 공유 할 수 있다
  - 잘쓰면 엄청 효율적이나... 디버깅이 힘들것 같다

## 3.8 예외 처리하기

- 예외: 처리하지 못한 에러
  - 노드 스레드가 멈춤
  - 노드는 기본적으로 싱글스레드라 스레드가 멈춘다는것은 프로세스가 멈추는것
  - 에러처리는 필수
- 기본적으로 try catch문으로 예외를 처리 하여 에러를 수집함
- 노드 비동기 메서드의 에러는 따로 처리하지 않아도 됨
- 프로미스의 에러는 따로 처리하지 않아도 됨
  - 그렇다 하더라고 프로미스에 catch를 꼭 붙이도록 하자
- `process.on('uncaughException')`이벤트로 모든 에러를 한번에 처리 할 수 있다.
  - 에러 기록용으로만 사용하도록 하자
- 프로세스 종료하기
  - 윈도우
    - netstat -ano | findstr 포트
    - taskkill /pid pid /f
  - 맥/리눅스
    - lsof -i tcp:포트
    - kill -9 pid